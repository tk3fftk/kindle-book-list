// Kindle Book Collector - Multi-page friendly script

// Helper function to sanitize text for CSV export
function sanitizeForCSV(text) {
  return text
    .replace(/,/g, "Ôºå") // Replace commas with full-width commas
    .replace(/"/g, '\\"'); // Escape double quotes with backslash
}

// Initialize the collector (run once)
window.initializeKindleCollector = function () {
  if (!window.kb) window.kb = [];

  // Collect books from current page
  window.collectBooks = function () {
    const books = [];
    document
      .querySelectorAll("table tr.ListItem-module_row__3orql")
      .forEach((row) => {
        // Extract title from the heading element
        const titleElement = row.querySelector(
          'div[role="heading"][aria-level="4"]'
        );
        const title = titleElement ? titleElement.textContent.trim() : "";

        // Extract author using the content-author ID pattern
        const authorElement = row.querySelector('div[id^="content-author-"]');
        const author = authorElement ? authorElement.textContent.trim() : "";

        if (title) {
          books.push({
            title: sanitizeForCSV(title),
            author: sanitizeForCSV(author),
            format: "Kindle",
          });
          console.log(`üìñ ${title} by ${author}`);
        }
      });

    window.kb.push(...books);
    console.log(
      `‚úÖ Added ${books.length} books from this page. Total: ${window.kb.length}`
    );
    return books.length;
  };

  // Page navigation helpers
  window.findNextPageButton = function () {
    // Find current active page
    const activePage = document.querySelector(".page-item.active");
    let nextButton = null;
    let currentPageNum = null;
    let nextPageNum = null;

    if (activePage) {
      // Get current page number from ID (e.g., "page-2" -> 2)
      currentPageNum = parseInt(activePage.id.replace("page-", ""));
      nextPageNum = currentPageNum + 1;

      // Try to find next numbered page
      nextButton = document.querySelector(`#page-${nextPageNum}`);
    }

    return { nextButton, currentPageNum, nextPageNum };
  };

  window.nextPage = function () {
    const { nextButton, currentPageNum, nextPageNum } =
      window.findNextPageButton();

    if (currentPageNum && nextPageNum) {
      console.log(
        `üîÑ Moving from page ${currentPageNum} to page ${nextPageNum}...`
      );
    }

    if (nextButton) {
      nextButton.click();
      console.log("üîÑ Navigating to next page...");
      console.log("üí° Wait for page to load, then run: collectBooks()");
    } else {
      console.log("‚ÑπÔ∏è No next page found - collection complete!");
      window.showResults();
    }
  };

  window.collectAllPages = function (options = {}) {
    const { mergeSequels = false } = options;

    console.log("üöÄ Starting automated collection...");
    if (mergeSequels) {
      console.log("üîó Auto-merge sequels enabled");
    }

    function collectAndNavigate() {
      setTimeout(() => {
        const count = window.collectBooks();
        if (count > 0) {
          setTimeout(() => {
            const { nextButton } = window.findNextPageButton();

            if (nextButton) {
              nextButton.click();
              console.log("üîÑ Auto-navigating to next page...");
              setTimeout(collectAndNavigate, 5000); // Wait 5 seconds for page load
            } else {
              finishCollection();
            }
          }, 1000);
        } else {
          finishCollection();
        }
      }, 1000);
    }

    function finishCollection() {
      window.showResults();
      if (mergeSequels) {
        console.log("üîó Auto-merging sequels...");
        setTimeout(() => {
          window.mergeSequels();
          window.showMerged();
        }, 1000);
      }
    }

    collectAndNavigate();
  };

  window.showResults = function () {
    console.log("\n" + "üéâ".repeat(20));
    console.log(`üìö Collection complete! Total books: ${window.kb.length}`);
    console.log("üíæ Use downloadCSV() or copyCSV() to export data");
    console.log("üîó Use mergeSequels() to combine sequel series");
    console.log("üéâ".repeat(20));
  };

  // Help function to show all available commands
  window.help = function () {
    console.log("üöÄ Kindle Book Collector - Available Commands:");
    console.log("\nüìö Collection Commands:");
    console.log("üìñ collectBooks()       - Collect books from current page");
    console.log("ü§ñ collectAllPages()    - Auto-collect from all pages");
    console.log(
      "üîó collectAllPages({mergeSequels: true}) - Auto-collect and merge"
    );
    console.log("üìä showResults()        - Show collection summary");

    console.log("\nüß≠ Navigation Commands:");
    console.log("‚û°Ô∏è nextPage()           - Navigate to next page");

    console.log("\nüìù Sequel Merging Commands:");
    console.log("üîó mergeSequels()       - Merge sequel series into ranges");
    console.log("üìö showMerged()         - Show merged collection summary");

    console.log("\nüíæ Export Commands:");
    console.log("üíæ downloadCSV()        - Download original CSV file");
    console.log("üìÅ exportMerged()       - Download merged CSV file");
    console.log("üìã copyCSV()            - Copy original CSV to clipboard");
    console.log("üìã copyMergedCSV()      - Copy merged CSV to clipboard");
    console.log("üìÑ toCSV()              - Get original CSV data as string");
    console.log("üìÑ toMergedCSV()        - Get merged CSV data as string");

    console.log("\nüîß Utility Commands:");
    console.log("‚ùì help()               - Show this help message");
    console.log("üîÑ initializeKindleCollector() - Re-initialize if needed");
    console.log("üß™ testSequelMerging()  - Test merging with sample data");

    console.log(
      `\nüìä Current Status: ${window.kb ? window.kb.length : 0} books collected`
    );
    if (window.kbMerged) {
      console.log(
        `üìä Merged Status: ${window.kbMerged.length} entries available`
      );
    }
  };

  console.log("üöÄ Kindle Collector initialized!");
  window.help();
};

// Initialize and collect from first page
if (!window.kb) {
  window.initializeKindleCollector();
}

// Sequel Pattern Recognition Functions
window.sequelPatterns = {
  // Pattern 1: Numbered volumes in parentheses (1), (2), ÔºàÔºëÔºâ, ÔºàÔºíÔºâ, etc.
  numberedVolumes: {
    regex: /^(.+?)[\(Ôºà]([\dÔºê-Ôºô]+)[\)Ôºâ](.*)$/,
    extract: function (title) {
      const match = title.match(this.regex);
      if (match) {
        const volumeText = match[2];
        let volume;
        
        // Convert full-width digits to half-width if needed
        if (/^[\d]+$/.test(volumeText)) {
          // Already ASCII digits
          volume = parseInt(volumeText);
        } else {
          // Convert full-width to half-width digits
          const halfWidthDigits = volumeText.replace(/[Ôºê-Ôºô]/g, char => 
            String.fromCharCode(char.charCodeAt(0) - 0xFF10 + 0x30)
          );
          volume = parseInt(halfWidthDigits);
        }
        
        return {
          baseTitle: match[1].trim(),
          volume: volume,
          volumeText: volume.toString(), // Always store as half-width for consistency
          suffix: match[3].trim(),
          type: "numbered",
        };
      }
      return null;
    },
  },

  // Pattern 2: Upper/Lower divisions (‰∏ä/‰∏ã)
  upperLower: {
    regex: /^(.+?)\s*([‰∏ä‰∏ã])\s*(.*)$/,
    extract: function (title) {
      const match = title.match(this.regex);
      if (match) {
        return {
          baseTitle: match[1].trim(),
          volume: match[2] === "‰∏ä" ? 1 : 2,
          volumeText: match[2],
          suffix: match[3].trim(),
          type: "upperLower",
        };
      }
      return null;
    },
  },

  // Pattern 3: Chapter format „ÄêÁ¨¨XË©±„Äë
  chapterFormat: {
    regex: /^(.+?)„ÄêÁ¨¨(\d+)Ë©±„Äë(.*)$/,
    extract: function (title) {
      const match = title.match(this.regex);
      if (match) {
        return {
          baseTitle: match[1].trim(),
          volume: parseInt(match[2]),
          suffix: match[3].trim(),
          type: "chapter",
        };
      }
      return null;
    },
  },

  // Pattern 4: Collection format Á¨¨XÈõÜ
  collectionFormat: {
    regex: /^(.+?)Á¨¨([‰∏Ä‰∫å‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅ\d]+)ÈõÜ(.*)$/,
    extract: function (title) {
      const match = title.match(this.regex);
      if (match) {
        const volumeText = match[2];
        let volume;

        // Convert Japanese numerals to numbers
        const japaneseNumerals = {
          ‰∏Ä: 1,
          ‰∫å: 2,
          ‰∏â: 3,
          Âõõ: 4,
          ‰∫î: 5,
          ÂÖ≠: 6,
          ‰∏É: 7,
          ÂÖ´: 8,
          ‰πù: 9,
          ÂçÅ: 10,
        };

        if (/^\d+$/.test(volumeText)) {
          volume = parseInt(volumeText);
        } else if (japaneseNumerals[volumeText]) {
          volume = japaneseNumerals[volumeText];
        } else {
          volume = 1; // Default fallback
        }

        return {
          baseTitle: match[1].trim(),
          volume: volume,
          volumeText: volumeText,
          suffix: match[3].trim(),
          type: "collection",
        };
      }
      return null;
    },
  },

  // Pattern 5: Volume format NÂ∑ª
  volumeKan: {
    regex: /^(.+?)(\d+)Â∑ª(.*)$/,
    extract: function (title) {
      const match = title.match(this.regex);
      if (match) {
        return {
          baseTitle: match[1].trim(),
          volume: parseInt(match[2]),
          volumeText: match[2],
          suffix: match[3].trim(),
          type: "volumeKan",
        };
      }
      return null;
    },
  },
};

// Function to detect and extract sequel information from a title
window.extractSequelInfo = function (title) {
  for (const [patternName, pattern] of Object.entries(window.sequelPatterns)) {
    const result = pattern.extract(title);
    if (result) {
      result.pattern = patternName;
      return result;
    }
  }
  return null; // No sequel pattern detected
};

// Function to group books by series (author + base title)
window.groupBooksBySeries = function (books) {
  const series = {};
  const standalone = [];

  books.forEach((book) => {
    const sequelInfo = window.extractSequelInfo(book.title);

    if (sequelInfo) {
      // This is part of a series
      const seriesKey = `${book.author}::${sequelInfo.baseTitle}::${sequelInfo.type}`;

      if (!series[seriesKey]) {
        series[seriesKey] = {
          author: book.author,
          baseTitle: sequelInfo.baseTitle,
          type: sequelInfo.type,
          volumes: [],
          suffix: sequelInfo.suffix, // Keep suffix from first volume
        };
      }

      series[seriesKey].volumes.push({
        volume: sequelInfo.volume,
        volumeText: sequelInfo.volumeText || sequelInfo.volume.toString(),
        originalTitle: book.title,
        format: book.format,
      });
    } else {
      // Standalone book
      standalone.push(book);
    }
  });

  // Sort volumes within each series
  Object.values(series).forEach((serie) => {
    serie.volumes.sort((a, b) => a.volume - b.volume);
  });

  return { series, standalone };
};

// Function to format volume ranges (consecutive vs non-consecutive)
window.formatVolumeRange = function (volumes, type) {
  if (volumes.length === 0) return "";
  if (volumes.length === 1) return volumes[0].volumeText;

  const volumeNumbers = volumes.map((v) => v.volume);

  // Special handling for upperLower type
  if (type === "upperLower") {
    const hasUpper = volumes.some((v) => v.volume === 1);
    const hasLower = volumes.some((v) => v.volume === 2);
    if (hasUpper && hasLower) {
      return "(‰∏ä„Éª‰∏ã)";
    } else if (hasUpper) {
      return "‰∏ä";
    } else {
      return "‰∏ã";
    }
  }

  // For other types, check if consecutive
  const isConsecutive = volumeNumbers.every((num, index) => {
    if (index === 0) return true;
    return num === volumeNumbers[index - 1] + 1;
  });

  const min = Math.min(...volumeNumbers);
  const max = Math.max(...volumeNumbers);

  if (isConsecutive && volumeNumbers.length > 2) {
    // Consecutive range: (1-21)
    switch (type) {
      case "numbered":
        return `(${min}-${max})`;
      case "chapter":
        return `„ÄêÁ¨¨${min}-${max}Ë©±„Äë`;
      case "collection":
        return `Á¨¨${min}-${max}ÈõÜ`;
      case "volumeKan":
        return `(${min}-${max})Â∑ª`;
      default:
        return `(${min}-${max})`;
    }
  } else {
    // Non-consecutive or short list: (1,3,5) or (1,2)
    const volumeTexts = volumes.map((v) => v.volumeText).join(",");
    switch (type) {
      case "numbered":
        return `(${volumeTexts})`;
      case "chapter":
        return `„ÄêÁ¨¨${volumeTexts}Ë©±„Äë`;
      case "collection":
        return `Á¨¨${volumeTexts}ÈõÜ`;
      case "volumeKan":
        return `(${volumeTexts})Â∑ª`;
      default:
        return `(${volumeTexts})`;
    }
  }
};

// Main function to merge sequels in the book collection
window.mergeSequels = function () {
  if (!window.kb || window.kb.length === 0) {
    console.log("‚ùå No books to merge. Collect some books first!");
    return;
  }

  console.log(`üîÑ Merging sequels from ${window.kb.length} books...`);

  const { series, standalone } = window.groupBooksBySeries(window.kb);
  const mergedBooks = [];

  // Add merged series
  Object.values(series).forEach((serie) => {
    if (serie.volumes.length > 1) {
      // Multiple volumes - merge them
      const volumeRange = window.formatVolumeRange(serie.volumes, serie.type);
      let mergedTitle;

      if (serie.type === "upperLower" && volumeRange === "(‰∏ä„Éª‰∏ã)") {
        mergedTitle = `${serie.baseTitle}${volumeRange}`;
      } else {
        mergedTitle = `${serie.baseTitle}${volumeRange}`;
      }

      if (serie.suffix) {
        mergedTitle += ` ${serie.suffix}`;
      }

      mergedBooks.push({
        title: mergedTitle,
        author: serie.author,
        format: serie.volumes[0].format,
        volumeCount: serie.volumes.length,
        originalTitles: serie.volumes.map((v) => v.originalTitle),
      });

      console.log(
        `üìö Merged: ${serie.baseTitle} (${serie.volumes.length} volumes) -> ${mergedTitle}`
      );
    } else {
      // Single volume series (shouldn't happen, but handle gracefully)
      const volume = serie.volumes[0];
      mergedBooks.push({
        title: volume.originalTitle,
        author: serie.author,
        format: volume.format,
      });
    }
  });

  // Add standalone books unchanged
  standalone.forEach((book) => {
    mergedBooks.push(book);
  });

  // Store merged data
  window.kbMerged = mergedBooks;

  console.log(`‚úÖ Merge complete!`);
  console.log(`üìä Original: ${window.kb.length} books`);
  console.log(`üìä Merged: ${mergedBooks.length} entries`);
  console.log(`üìä Series merged: ${Object.keys(series).length}`);
  console.log(`üìä Standalone books: ${standalone.length}`);
  console.log(`üíæ Use exportMerged() to download merged CSV`);

  return mergedBooks;
};

// Function to show merged results
window.showMerged = function () {
  if (!window.kbMerged) {
    console.log("‚ùå No merged data available. Run mergeSequels() first!");
    return;
  }

  console.log("\n" + "üìö".repeat(20));
  console.log(
    `üìä Merged Collection Summary (${window.kbMerged.length} entries)`
  );
  console.log("üìö".repeat(20));

  const seriesEntries = window.kbMerged.filter((book) => book.volumeCount);
  const standaloneEntries = window.kbMerged.filter((book) => !book.volumeCount);

  if (seriesEntries.length > 0) {
    console.log(`\nüìñ Series (${seriesEntries.length} entries):`);
    seriesEntries.forEach((entry) => {
      console.log(
        `  üìö ${entry.title} by ${entry.author} (${entry.volumeCount} volumes)`
      );
    });
  }

  if (standaloneEntries.length > 0) {
    console.log(`\nüìï Standalone books (${standaloneEntries.length} entries):`);
    standaloneEntries.slice(0, 10).forEach((entry) => {
      console.log(`  üìï ${entry.title} by ${entry.author}`);
    });
    if (standaloneEntries.length > 10) {
      console.log(
        `  ... and ${standaloneEntries.length - 10} more standalone books`
      );
    }
  }

  console.log(`\nüíæ Export options:`);
  console.log(`üìÅ Download merged CSV: exportMerged()`);
  console.log(`üìã Copy merged CSV: copyMergedCSV()`);
};

// Export functions for merged data
window.toMergedCSV = function () {
  if (!window.kbMerged) {
    console.log("‚ùå No merged data available. Run mergeSequels() first!");
    return "";
  }

  const header = "Title,Author,Format\n";
  const rows = window.kbMerged
    .map((book) => `"${book.title}","${book.author}","${book.format}"`)
    .join("\n");
  return header + rows;
};

window.exportMerged = function () {
  const csv = window.toMergedCSV();
  if (!csv) return;

  const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
  const link = document.createElement("a");
  const timestamp = new Date().toISOString().split("T")[0];
  link.download = `kindle_books_merged_${timestamp}.csv`;
  link.href = URL.createObjectURL(blob);
  link.click();
  console.log(`üìÅ Downloaded merged CSV: kindle_books_merged_${timestamp}.csv`);
};

window.copyMergedCSV = async function () {
  const csv = window.toMergedCSV();
  if (!csv) return;

  try {
    await navigator.clipboard.writeText(csv);
    console.log(
      `üìã Merged CSV copied to clipboard! (${window.kbMerged.length} entries)`
    );
  } catch (err) {
    console.log(`‚ùå Failed to copy to clipboard: ${err.message}`);
    console.log(`üí° Manual copy: Select and copy the CSV data below:`);
    console.log(csv);
  }
};

// CSV Export Functions
window.toCSV = function () {
  const header = "Title,Author,Format\n";
  const rows = window.kb
    .map((book) => `"${book.title}","${book.author}","${book.format}"`)
    .join("\n");
  return header + rows;
};

window.downloadCSV = function () {
  const csv = window.toCSV();
  const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
  const link = document.createElement("a");
  const timestamp = new Date().toISOString().split("T")[0];
  link.download = `kindle_books_${timestamp}.csv`;
  link.href = URL.createObjectURL(blob);
  link.click();
  console.log(`üìÅ Downloaded CSV file: kindle_books_${timestamp}.csv`);
};

window.copyCSV = async function () {
  const csv = window.toCSV();
  try {
    await navigator.clipboard.writeText(csv);
    console.log(`üìã CSV data copied to clipboard! (${window.kb.length} books)`);
  } catch (err) {
    console.log(`‚ùå Failed to copy to clipboard: ${err.message}`);
    console.log(`üí° Manual copy: Select and copy the CSV data below:`);
    console.log(csv);
  }
};

// Test function for sequel merging
window.testSequelMerging = function () {
  console.log("üß™ Testing sequel merging with sample data...");

  // Sample test data based on output.csv patterns
  const testBooks = [
    {
      title: "„Éó„É©„É≥„ÉÄ„É©(1) (ËßíÂ∑ù„Ç≥„Éü„ÉÉ„ÇØ„Çπ„Éª„Ç®„Éº„Çπ)",
      author: "Ê∞¥ÁÑ°Êúà „Åô„ÅÜ",
      format: "Kindle",
    },
    {
      title: "„Éó„É©„É≥„ÉÄ„É©(2) (ËßíÂ∑ù„Ç≥„Éü„ÉÉ„ÇØ„Çπ„Éª„Ç®„Éº„Çπ)",
      author: "Ê∞¥ÁÑ°Êúà „Åô„ÅÜ",
      format: "Kindle",
    },
    {
      title: "„Éó„É©„É≥„ÉÄ„É©(3) (ËßíÂ∑ù„Ç≥„Éü„ÉÉ„ÇØ„Çπ„Éª„Ç®„Éº„Çπ)",
      author: "Ê∞¥ÁÑ°Êúà „Åô„ÅÜ",
      format: "Kindle",
    },
    {
      title: "„Éó„É©„É≥„ÉÄ„É©(21) (ËßíÂ∑ù„Ç≥„Éü„ÉÉ„ÇØ„Çπ„Éª„Ç®„Éº„Çπ)",
      author: "Ê∞¥ÁÑ°Êúà „Åô„ÅÜ",
      format: "Kindle",
    },
    {
      title: "NEXUS ÊÉÖÂ†±„ÅÆ‰∫∫È°ûÂè≤ ‰∏ä„ÄÄ‰∫∫Èñì„ÅÆ„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ",
      author: "„É¶„É¥„Ç°„É´„Éª„Éé„Ç¢„Éª„Éè„É©„É™",
      format: "Kindle",
    },
    {
      title: "NEXUS ÊÉÖÂ†±„ÅÆ‰∫∫È°ûÂè≤ ‰∏ã„ÄÄAIÈù©ÂëΩ",
      author: "„É¶„É¥„Ç°„É´„Éª„Éé„Ç¢„Éª„Éè„É©„É™",
      format: "Kindle",
    },
    { title: "„ÅÇ„Åö„Åæ„Çì„ÅåÂ§ßÁéã(1)", author: "„ÅÇ„Åö„Åæ„Åç„Çà„Å≤„Åì", format: "Kindle" },
    { title: "„ÅÇ„Åö„Åæ„Çì„ÅåÂ§ßÁéã(2)", author: "„ÅÇ„Åö„Åæ„Åç„Çà„Å≤„Åì", format: "Kindle" },
    { title: "„ÅÇ„Åö„Åæ„Çì„ÅåÂ§ßÁéã(3)", author: "„ÅÇ„Åö„Åæ„Åç„Çà„Å≤„Åì", format: "Kindle" },
    { title: "„ÅÇ„Åö„Åæ„Çì„ÅåÂ§ßÁéã(4)", author: "„ÅÇ„Åö„Åæ„Åç„Çà„Å≤„Åì", format: "Kindle" },
    {
      title: "‰∏çÊµÑ„ÇíÊã≠„ÅÜ„Å≤„Å®ÔºàÂàÜÂÜäÁâàÔºâ „ÄêÁ¨¨1Ë©±„Äë (Êú¨ÂΩì„Å´„ÅÇ„Å£„ÅüÁ¨ë„Åà„ÇãË©±)",
      author: "Ê≤ñÁî∞√óËèØ",
      format: "Kindle",
    },
    {
      title: "‰∏çÊµÑ„ÇíÊã≠„ÅÜ„Å≤„Å®ÔºàÂàÜÂÜäÁâàÔºâ „ÄêÁ¨¨2Ë©±„Äë (Êú¨ÂΩì„Å´„ÅÇ„Å£„ÅüÁ¨ë„Åà„ÇãË©±)",
      author: "Ê≤ñÁî∞√óËèØ",
      format: "Kindle",
    },
    {
      title: "‰∏çÊµÑ„ÇíÊã≠„ÅÜ„Å≤„Å®ÔºàÂàÜÂÜäÁâàÔºâ „ÄêÁ¨¨3Ë©±„Äë (Êú¨ÂΩì„Å´„ÅÇ„Å£„ÅüÁ¨ë„Åà„ÇãË©±)",
      author: "Ê≤ñÁî∞√óËèØ",
      format: "Kindle",
    },
    {
      title: "Á¨¨‰∏ÄÈõÜ: „Äå„ÅÑ„Å™„Åí„ÇÑ„ÅÆË©± ‰ªñ„Äç Â∑ùÂ∞ª„Åì„Å†„Åæ„ÅÆ„Åü„Å†„Çå„ÅüÁîüÊ¥ª",
      author: "Â∑ùÂ∞ª„Åì„Å†„Åæ",
      format: "Kindle",
    },
    {
      title: "Á¨¨2ÈõÜ: „ÄåÁî∫‰∏≠ËèØ„ÅÆË©± ‰ªñ„Äç Â∑ùÂ∞ª„Åì„Å†„Åæ„ÅÆ„Åü„Å†„Çå„ÅüÁîüÊ¥ª",
      author: "Â∑ùÂ∞ª„Åì„Å†„Åæ",
      format: "Kindle",
    },
    {
      title: "Á¨¨‰∏âÈõÜ: „Äé‰ªÆÁú†„É©„Ç§„Éï„Éè„ÉÉ„ÇØ„ÅÆË©± ‰ªñ„Äè Â∑ùÂ∞ª„Åì„Å†„Åæ„ÅÆ„Åü„Å†„Çå„ÅüÁîüÊ¥ª",
      author: "Â∑ùÂ∞ª„Åì„Å†„Åæ",
      format: "Kindle",
    },
    { title: "ÂçòÁã¨„ÅÆÊú¨", author: "„ÉÜ„Çπ„Éà‰ΩúËÄÖ", format: "Kindle" },
    {
      title: "Get Backers Â•™ÈÇÑÂ±ã„ÄêÊ•µÔºÅÂçòË°åÊú¨„Ç∑„É™„Éº„Ç∫„Äë9Â∑ª",
      author: "ÈùíÊ®π‰ΩëÂ§úÔºå Á∂æÂ≥∞Ê¨Ñ‰∫∫",
      format: "Kindle",
    },
    {
      title: "Get Backers Â•™ÈÇÑÂ±ã„ÄêÊ•µÔºÅÂçòË°åÊú¨„Ç∑„É™„Éº„Ç∫„Äë13Â∑ª",
      author: "ÈùíÊ®π‰ΩëÂ§úÔºå Á∂æÂ≥∞Ê¨Ñ‰∫∫",
      format: "Kindle",
    },
    {
      title: "Get Backers Â•™ÈÇÑÂ±ã„ÄêÊ•µÔºÅÂçòË°åÊú¨„Ç∑„É™„Éº„Ç∫„Äë29Â∑ª",
      author: "ÈùíÊ®π‰ΩëÂ§úÔºå Á∂æÂ≥∞Ê¨Ñ‰∫∫",
      format: "Kindle",
    },
    {
      title: "Get Backers Â•™ÈÇÑÂ±ã„ÄêÊ•µÔºÅÂçòË°åÊú¨„Ç∑„É™„Éº„Ç∫„Äë8Â∑ª",
      author: "ÈùíÊ®π‰ΩëÂ§úÔºå Á∂æÂ≥∞Ê¨Ñ‰∫∫",
      format: "Kindle",
    },
    {
      title: "Get Backers Â•™ÈÇÑÂ±ã„ÄêÊ•µÔºÅÂçòË°åÊú¨„Ç∑„É™„Éº„Ç∫„Äë33Â∑ª",
      author: "ÈùíÊ®π‰ΩëÂ§úÔºå Á∂æÂ≥∞Ê¨Ñ‰∫∫",
      format: "Kindle",
    },
    {
      title: "Get Backers Â•™ÈÇÑÂ±ã„ÄêÊ•µÔºÅÂçòË°åÊú¨„Ç∑„É™„Éº„Ç∫„Äë23Â∑ª",
      author: "ÈùíÊ®π‰ΩëÂ§úÔºå Á∂æÂ≥∞Ê¨Ñ‰∫∫",
      format: "Kindle",
    },
    {
      title: "„Éò„ÉÜ„É≠„Ç≤„Éã„Ç¢„ÄÄ„É™„É≥„ÇÆ„Çπ„ÉÜ„Ç£„Ç≥„ÄÄÔΩûÁï∞Á®ÆÊóèË®ÄË™ûÂ≠¶ÂÖ•ÈñÄÔΩû„ÄÄÔºàÔºñÔºâ (ËßíÂ∑ù„Ç≥„Éü„ÉÉ„ÇØ„Çπ„Éª„Ç®„Éº„Çπ)",
      author: "ÁÄ¨Èáé Âèç‰∫∫",
      format: "Kindle",
    },
    {
      title: "„Éò„ÉÜ„É≠„Ç≤„Éã„Ç¢„ÄÄ„É™„É≥„ÇÆ„Çπ„ÉÜ„Ç£„Ç≥„ÄÄÔΩûÁï∞Á®ÆÊóèË®ÄË™ûÂ≠¶ÂÖ•ÈñÄÔΩû„ÄÄÔºàÔºïÔºâ (ËßíÂ∑ù„Ç≥„Éü„ÉÉ„ÇØ„Çπ„Éª„Ç®„Éº„Çπ)",
      author: "ÁÄ¨Èáé Âèç‰∫∫",
      format: "Kindle",
    },
    {
      title: "„Éò„ÉÜ„É≠„Ç≤„Éã„Ç¢„ÄÄ„É™„É≥„ÇÆ„Çπ„ÉÜ„Ç£„Ç≥„ÄÄÔΩûÁï∞Á®ÆÊóèË®ÄË™ûÂ≠¶ÂÖ•ÈñÄÔΩû„ÄÄÔºàÔºîÔºâ (ËßíÂ∑ù„Ç≥„Éü„ÉÉ„ÇØ„Çπ„Éª„Ç®„Éº„Çπ)",
      author: "ÁÄ¨Èáé Âèç‰∫∫",
      format: "Kindle",
    },
    {
      title: "„Éû„ÉÜ„É™„Ç¢„É´„Éª„Éë„Ç∫„É´ÔΩûÁ•ûÁÑ°„Åç‰∏ñÁïå„ÅÆÈ≠îÊ≥ï‰Ωø„ÅÑÔΩûÔºàÔºëÔºêÔºâ („É¢„Éº„Éã„É≥„Ç∞„Ç≥„Éü„ÉÉ„ÇØ„Çπ)",
      author: "ÂúüÂ°öÁêÜÂºò",
      format: "Kindle",
    },
    {
      title: "„Éû„ÉÜ„É™„Ç¢„É´„Éª„Éë„Ç∫„É´ÔΩûÁ•ûÁÑ°„Åç‰∏ñÁïå„ÅÆÈ≠îÊ≥ï‰Ωø„ÅÑÔΩûÔºàÔºôÔºâ („É¢„Éº„Éã„É≥„Ç∞„Ç≥„Éü„ÉÉ„ÇØ„Çπ)",
      author: "ÂúüÂ°öÁêÜÂºò",
      format: "Kindle",
    },
  ];

  // Backup current data if it exists
  const originalKb = window.kb;
  window.kb = testBooks;

  console.log(`üìö Loaded ${testBooks.length} test books`);

  // Test the merging
  const result = window.mergeSequels();

  console.log("\nüß™ Test Results:");
  console.log("Expected merges:");
  console.log("  - „Éó„É©„É≥„ÉÄ„É©(1,2,3,21) (non-consecutive, half-width)");
  console.log("  - NEXUS ÊÉÖÂ†±„ÅÆ‰∫∫È°ûÂè≤(‰∏ä„Éª‰∏ã)");
  console.log("  - „ÅÇ„Åö„Åæ„Çì„ÅåÂ§ßÁéã(1-4) (consecutive, half-width)");
  console.log("  - ‰∏çÊµÑ„ÇíÊã≠„ÅÜ„Å≤„Å®ÔºàÂàÜÂÜäÁâàÔºâ „ÄêÁ¨¨1-3Ë©±„Äë");
  console.log("  - Â∑ùÂ∞ª„Åì„Å†„Åæ„ÅÆ„Åü„Å†„Çå„ÅüÁîüÊ¥ª Á¨¨1-3ÈõÜ");
  console.log("  - Get Backers Â•™ÈÇÑÂ±ã„ÄêÊ•µÔºÅÂçòË°åÊú¨„Ç∑„É™„Éº„Ç∫„Äë(8,9,13,23,29,33)Â∑ª");
  console.log("  - „Éò„ÉÜ„É≠„Ç≤„Éã„Ç¢„ÄÄ„É™„É≥„ÇÆ„Çπ„ÉÜ„Ç£„Ç≥„ÄÄÔΩûÁï∞Á®ÆÊóèË®ÄË™ûÂ≠¶ÂÖ•ÈñÄÔΩû„ÄÄÔºà4-6Ôºâ (full-width)");
  console.log("  - „Éû„ÉÜ„É™„Ç¢„É´„Éª„Éë„Ç∫„É´ÔΩûÁ•ûÁÑ°„Åç‰∏ñÁïå„ÅÆÈ≠îÊ≥ï‰Ωø„ÅÑÔΩûÔºà9,10Ôºâ (full-width)");
  console.log("  - ÂçòÁã¨„ÅÆÊú¨ (unchanged)");

  console.log(`\n‚úÖ Actual result: ${result.length} entries (expected ~9)`);

  if (window.kbMerged) {
    window.showMerged();
  }

  // Restore original data
  window.kb = originalKb;

  console.log("\nüß™ Test complete! Original data restored.");
};

// Show export options
if (window.kb.length > 0) {
  console.log("\n" + "=".repeat(50));
  console.log(`üìö ${window.kb.length} books collected. Export options:`);
  console.log("üíæ Download file: downloadCSV()");
  console.log("üìã Copy to clipboard: copyCSV()");
  console.log("‚û°Ô∏è Navigate to next page: nextPage()");
  console.log("üß™ Test sequel merging: testSequelMerging()");
  console.log("=".repeat(50));
}
